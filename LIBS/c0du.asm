;
;  Copyright (c) 2016, Alexey Frunze
;  2-clause BSD license.
;
bits 16

    extern ___start__
    extern __start__relot, __stop__relot
    extern __start__relod, __stop__relod
    extern __start__bss
    extern __stop__bss

section .text

    global __start
__start:

    ; Perform code and data relocations.
    ; Do this without using unreal (AKA big real) mode to make sure that
    ; it doesn't get disabled in the process by some driver or ISR.

    call .labnext 
.labnext:
    xor     ebx, ebx
    mov     bx, cs
    shl     ebx, 4
    xor     eax, eax
    pop     ax
    add     ebx, eax
    sub     ebx, .labnext ; ebx = base physical address

    ; Patch addresses recorded in .relod (.relod is generated by the linker).
    ; [Note that the .relot section (handled later) contains some of the same
    ; addresses contained in the .relod section and .relod must be processed
    ; before .relot. .relot is used to transform flat 32-bit addresses into
    ; far addresses of a form segment:offset and this can only be done when
    ; the address relocation (using .relod) has been done.]
    ; Note that the following loop patches addresses in both code and data,
    ; including the addresses in the two following instructions!
    mov     esi, __start__relod
    mov     edx, __stop__relod
.relo_data_loop:
    cmp     esi, edx
    jae     .relo_data_done

    lea     edi, [ebx + esi] ; edi = physical address of a relocation table element

    ror     edi, 4
    mov     ds, di
    shr     edi, 28

    mov     edi, [di]
    add     edi, ebx ; edi = physical address of a dword to which to add ebx

    ror     edi, 4
    mov     ds, di
    shr     edi, 28

    add     [di], ebx ; actual relocation

    add     esi, 4
    jmp     .relo_data_loop
.relo_data_done:

    ; Patch direct calls recorded in .relot (.relot is generated by the compiler
    ; and/or written by the programmer).
    mov     esi, __start__relot
    mov     edx, __stop__relot
.relo_text_loop:
    cmp     esi, edx
    jae     .relo_text_done

    mov     edi, esi ; edi = physical address of a relocation table element
    ror     edi, 4
    mov     ds, di
    shr     edi, 28

    mov     edi, [di] ; edi = address of an address which to transform into seg:ofs far address

    ror     edi, 4
    mov     ds, di
    shr     edi, 28

    mov     eax, [di]
    shl     eax, 12
    rol     ax, 4
    mov     [di], eax ; actual transformation

    add     esi, 4
    jmp     .relo_text_loop
.relo_text_done:

    ; Init .bss

    mov     edi, __start__bss
    mov     ebx, __stop__bss
    sub     ebx, edi
    ror     edi, 4
    mov     es, di
    shr     edi, 28
    xor     al, al
    cld

.bss1:
    mov     ecx, 32768
    cmp     ebx, ecx
    jc      .bss2

    sub     ebx, ecx
    rep     stosb
    and     di, 15
    mov     si, es
    add     si, 2048
    mov     es, si
    jmp     .bss1

.bss2:
    mov     cx, bx
    rep     stosb




   
    xor     ax, ax ; this is general clearing up
    mov     ds, ax
    mov     es, ax

 

    ; Call __start__(), which will set up argc and argv for main() and call exit(main(argc, argv))
    db      0xEA
.patch_start_addr:
    dd      ___start__
    ; __start__() shouldn't return



section .relot ; .relot must exist for __start__relot and __stop__relot to also exist
    dd      __start.patch_start_addr ; patch the far call to __start__()


;section .relod ; .relod must exist for __start__relod and __stop__relod to also exist
;               ; the linker will generate .relod for us

section .bss ; .bss must exist for __start__bss and __stop__bss to also exist
;    global ___GpCnt

